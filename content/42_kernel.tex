% vim:set ft=tex
\section{Kernel Performance Counter}
\label{impl:perfcounter}

\gls{intel} provides hardware performance counter for various CPU
architectures.
Software developers should be enabled to observe the behaviour of their
software and examine bottlenecks or performance hotspots.

The performance monitoring capabilities of the targeted Haswell architecture
were presented in section \ref{state:haswell}.

The present kernel implementation for architectural performance monitoring is
extended to use the fixed-function counters for unhalted core cycles and
instructions retired.
Additionally, a general purpose counter for \gls{llc} misses is used,
leaving three counters for future use.

\paragraph{Configuring \& starting the counters}
Each general purpose performance counter consists of a counter register and a
configuration register.
The configuration register must be filled with the counter ``UMask'' and
``Event Select'' to specify the event which should be counted.
Then user and operating system mode bits must be set, to count events happening
in both, privileged and unprivileged mode.
With the edge detect bit set, every new occurrence of the selected event is
counted.
If the event was present and happens again before it was counted, it counts as
a single event.
At last the enable bit must be set to start counting, but only if the counter
is also enabled in the global control register.

Fixed-function counters consist of a counter and a shared control register to
en- and disable each one.

But both counter types only start counting, if they are enabled in the global
performance monitoring control register.
This register contains a bit for each counter, which must also be set to enable
the counter.

Fiasco.OC already contains the boot parameter '-loadcnt' enabling the unhalted
core cycle counter on each core.
Although a fixed-function counter is available for this event, the
implementation still used a general purpose counter.
Using this flag, all mentioned events are configured and enabled on each core.

\paragraph{Accounting per thread}
% todo find out, where and when thread perf counting is enabled?
After performance counting is enabled for a thread,
Fiasco.OC adds the counter values on each context switch to the thread's
account and resets the counter to zero.


\paragraph{user land interface}
Two new thread operations are introduced: perf\_read and perf\_reset.
Perf\_read fills a passed perf\_counter struct with the values passed from the
kernel, whereas perf\_reset tells the kernel to set all counters to zero.

\begin{lstlisting}[language=c++]
enum L4_thread_ops {
  ...
  L4_THREAD_PERF_READ_OP	      = 10UL,
  /**< Read thread's performance counter */
  L4_THREAD_PERF_RESET_OP	      =	11UL,
  /**< Reset thread's performance counter */
  ...
}

struct perf_counter_read_t {
  l4_uint64_t core_cycle_cnt;
  l4_uint64_t instr_retired_cnt;
  l4_uint64_t llc_miss_cnt;
};
typedef struct perf_counter_read_t perf_counter_read_t;

L4_INLINE l4_msgtag_t
l4_thread_perf_read(l4_cap_idx_t thread,
                    perf_counter_read_t *cntr) L4_NOTHROW;

L4_INLINE l4_msgtag_t
l4_thread_perf_reset(l4_cap_idx_t thread) L4_NOTHROW;
\end{lstlisting}
